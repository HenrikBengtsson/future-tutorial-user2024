[
  {
    "objectID": "lab1.html",
    "href": "lab1.html",
    "title": "Lab: Futureverse 1",
    "section": "",
    "text": "Note\n\n\n\nThis is the first of two parallelization labs. It will take you through some basic steps to parallelize your code using Futureverse. It focuses on core functions future() and value() for the purpose of illustrating what happens behind the scenes when we parallelize R code.\nYou are highly encouraged to test things out yourself and tweak things to figure out how these methods behave.\nSlides: ‘Futureverse: A Unifying Parallelization Framework in R for Everyone - Part 1’"
  },
  {
    "objectID": "lab1.html#install",
    "href": "lab1.html#install",
    "title": "Lab: Futureverse 1",
    "section": "Install",
    "text": "Install\nWe will start out by installing common Futureverse packages part of the Futureverse. We will not need them all in this lab, but it is convenient to have them all installed already now.\n\ninstall.packages(\"futureverse\")"
  },
  {
    "objectID": "lab1.html#exercises",
    "href": "lab1.html#exercises",
    "title": "Lab: Futureverse 1",
    "section": "Exercises",
    "text": "Exercises\nIn order to illustrate parallelization, we need two things: (i) a way to measure time, and (ii) something that takes at least a few seconds to run.\nTask 1:\nCopy and paste the following two code blocks.\nCreate functions tic() and toc() to measure time:\n\ntic &lt;- function() {\n  tic_start &lt;&lt;- base::Sys.time()\n}\n\ntoc &lt;- function() {\n  dt &lt;- base::difftime(base::Sys.time(), tic_start)\n  dt &lt;- round(dt, digits = 1L)\n  message(paste(format(dt), \"since tic()\"))\n}\n\nThese functions can be used as a timer, e.g.\n\ntic()\nSys.sleep(1.5)\ntoc()\n\n\n\n1.5 secs since tic()\n\n\n\nSys.sleep(4.0)\ntoc()\n\n\n\n5.5 secs since tic()\n\n\nNext, create toy function slow_sum() for calculating the sum of a vector really slowly:\n\nslow_sum &lt;- function(x) {\n  sum &lt;- 0\n  for (value in x) {\n    Sys.sleep(1.0)     ## one-second slowdown per value\n    sum &lt;- sum + value\n  }\n  sum\n}\n\nThis function works just like sum(), but it is very slow. If we use it to calculate \\(1 + 2 + \\ldots + 10\\), it will takes us ten seconds to get the result;\n\ntic()\ny &lt;- slow_sum(1:10)\ny\ntoc()\n\nMake sure you can run the latter, that it takes ten seconds to complete and that it returns the correct value.\nWe are now ready to get rolling!\n\nSimple parallel tasks\nAt the very core of Futureverse is the future package. Let us start out by loading this core package:\n\nlibrary(future)\n\nIt provides us with the fundamental building blocks for running R code in parallel; functions future(), value(), and resolved(). Other Futureverse packages, such as future.apply, furrr, and doFuture, rely on these three functions to build up more feature-rich functions. We will return to those later, but for now we will focus on future() and value().\nTask 2:\nLet’s start by writing our initial example using futures:\n\ntic()\nf &lt;- future(slow_sum(1:10))\ny &lt;- value(f)\ntoc()\n\nConfirm that you get the correct result. Did it run faster?\n\nTask 3:\nAdd another toc() just after the future() call;\n\ntic()\nf &lt;- future(slow_sum(1:10))\ntoc()\ny &lt;- value(f)\ntoc()\ny\ntoc()\n\nHow long did the creation of the future take?\n\nTask 4:\nBy design, Futureverse runs everything sequentially by default. We can configure it run code in parallel using two background workers as:\n\nplan(multisession, workers = 2)\n\nMake this change, and rerun the above example. Did the different steps take as long as you expected? What do you think the reason is for the change?\n\nTask 5:\nLet’s calculate \\(1 + 2 + \\ldots + 10\\) in two steps: (a) \\(1 + 2 +\n\\ldots + 5\\) and (b) \\(6 + 7 + \\ldots + 10\\), and then sum the two results.\n\nfa &lt;- future(slow_sum(1:5))\nfb &lt;- future(slow_sum(6:10))\ny &lt;- value(fa) + value(fb)\ny\n\nBut first, make sure to add toc() after each statement to better understand how long each step takes;\n\ntic()\nfa &lt;- future(slow_sum(1:5))\ntoc()\nfb &lt;- future(slow_sum(6:10))\ntoc()\ny &lt;- value(fa) + value(fb)\ntoc()\ny\ntoc()\n\nMake sure you get the expected result. Did it finish sooner? Which step takes the longest? Why do you think that is?\n\n\n\nCreate many parallel tasks via a for loop\nTask 6:\nHere is a very complicated way of calculating the sum \\(1 + 2 + \\ldots\n+ 20\\) in four chunks and outputting messages to show the progress:\n\ntic()\nxs &lt;- list(1:5, 6:10, 11:15, 16:20)\nys &lt;- list()\nfor (ii in seq_along(xs)) {\n  message(paste0(\"Iteration \", ii))\n  ys[[ii]] &lt;- slow_sum(xs[[ii]])\n}\nmessage(\"Done\")\nprint(ys)\n\nys &lt;- unlist(ys)\nys\n\ny &lt;- sum(ys)\ny\ntoc()\n\nRewrite it such that each iteration is parallelized via a future. Use four parallel workers as in:\n\nlibrary(future)\nplan(multisession, workers = 4)\n\n\nTask 7:\nRetry with three parallel workers as in:\n\nlibrary(future)\nplan(multisession, workers = 3)\n\nDid you notice something? What do you think happened?\n\n\nOur own parallel lapply\nTask 8:\nAbove, you used a for-loop to parallelize tasks. See if you can achieve the same using lapply() instead.\nTask 9:\nTake your parallel lapply() code and wrap it up in a function parallel_lapply() that takes two arguments X and FUN so that we can call:\n\nlibrary(future)\nplan(multisession)\n\nxs &lt;- list(1:5, 6:10, 11:15, 16:20)\n\nys &lt;- parallel_lapply(xs, slow_sum)\nys &lt;- unlist(ys)\ny &lt;- sum(ys)\n\n\n\n\nErrors and parallel processing\nThe Futureverse has been designed such that your experience running parallel code will be as close as possible to when you run regular, sequential code. For example, if we call:\n\nx &lt;- \"1.2\"\ny &lt;- log(x)\n\nError in log(x): non-numeric argument to mathematical function\n\n\nwe get an error.\nTask 10:\nIf we try the same with a future, it’s natural to expect the same error;\n\nf &lt;- future(log(x))\n\nRun the above. Did you get an error or not? What could be the reason for that?\n\nIf we try to get the value of f as in\n\ny &lt;- value(f)\n\nwhat happens?\n\n\n\n\n\n\n\nNote\n\n\n\nAt first, it might appear obvious that we should get an error in these cases and that it will look the same as when running regular sequential code. But rest assured, Futureverse is the only parallel framework that behave this way. If you use one of the traditional frameworks you will get a different type of error, or not an error at all. This is the case for parLapply() and mclapply() of parallel as well as for foreach() and %dopar% of foreach.\n\n\nTask 11:\nTry with the following sequential code:\n\nX &lt;- list(\"1.2\", 42)\ny &lt;- lapply(X, log)\n\nDid you get an error?\nTask 12:\nNext, try the same but with mclapply() of the parallel package;\n\nlibrary(parallel)\n\nX &lt;- list(\"1.2\", 42)\ny &lt;- mclapply(X, log)\n\nWhat happened - did you get an error?\nWhat do you get if you look at y, e.g. print(y) or str(y)?\nTask 13:\nFinally, try the same but with your parallel_lapply() that uses Futureverse:\n\nlibrary(future)\nplan(multisession)\n\nX &lt;- list(\"1.2\", 42)\ny &lt;- parallel_lapply(X, log)\n\nComment: Expand the following for a working version of parallel_lapply().\n\n\nparallel_lapply()\n\nparallel_lapply &lt;- function(X, FUN) {\n  ## Create futures that calls FUN(X[[1]]), FUN(X[[2]]), ...\n  fs &lt;- lapply(X, function(x) {\n    ## For element 'x', create future that calls FUN(x)\n    future(FUN(x))\n  })\n  \n  ## Collect the values from all futures\n  value(fs)\n}\n\n\nDid you get an error?\nTask 14:\nLet’s continue with our future-based example. What do you think the behavior is if we switch back to sequential processing using:\n\nplan(sequential)\n\nf &lt;- future(log(x))\ny &lt;- value(f)\n\n? Try it. What do you observe? Did you expect something different? Did the error happen already when calling future() or when calling value()?\nWhen done, make sure to switch back to parallel processing again:\n\nplan(multisession, workers = 2)\n\n\n\nWarnings and parallel processing\nJust like errors, warnings are signalled as-is when parallelizing via futures.\nTask 15:\nTry the following:\n\nx &lt;- c(1.2, -0.5)\nf &lt;- future(log(x))\ny &lt;- value(f)\ny\n\nDid you get a warning? By the way, how do you think the parallel worker that runs in the background and evalutes log(x) knows what the value of x is?"
  }
]