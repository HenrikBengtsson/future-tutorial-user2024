---
title: "Lab: Futureverse 2"
author: "Henrik Bengtsson"
description: "Speed up your code through parallel computing"
image: "assets/featured.jpg"
format: html
---

```{r, echo = FALSE}
task_count <- 0L
task <- function() {
  task_count <<- task_count + 1L
  task_count
}
```

```{r, echo = FALSE}
slow_sum <- base::sum

## Allow workers = 4, even if we only have access to two cores
options(parallelly.maxWorkers.localhost = c(Inf, Inf))
```

::: {.callout-note}

This is the second of two parallelization labs. It will take you
through **[Futureverse]** functions that you and others are likely to
use to parallelize R code.  We will cover the **future.apply**
package, **furrr** package, and **foreach** with the **DoFuture**
package. In your R career, you pick whichever you prefer - they are
all equally good.

You are highly encouraged to test things out yourself and tweak things
to figure out how these methods behave.

Slides: ['Futureverse: A Unifying Parallelization Framework in R for
Everyone - Part 2'](BengtssonH_20240612-futureverse-part2-raukR_2024.pdf)

:::



## Install

It is assumed that you have already installed common Futureverse
packages in Lab 1. If not, install them now as:

```{r}
#| eval: false
install.packages("futureverse")
```


## Exercises

### Recap from Lab 1

In the first part - Lab 1 - we learned about the `future()` and
`value()` functions part of the **[future]** package.  They allow us
to run independent tasks is parallel, e.g.

```{r}
library(future)
plan(multisession, workers = 4)

xs <- list(1:50, 51:100)
fa <- future(slow_sum(xs[[1]]))
fb <- future(slow_sum(xs[[2]]))
a <- value(fa)
b <- value(fb)
y <- a + b
y
```

If you end up using this `future()`/`value()`-style of parllelization
frequently, you might be interested in `%<-%`, which combines the two
in a easy-to-read fashion.  We refer to `%<-%` as the _future_
assignment operator, because it closely resembles regular `<-`
assignment operator. Not always, but in many cases we can just replace
`<-` with `%<-%` to call a function, or evaluate some expression in
parallel.  Try this with:

```{r}
xs <- list(1:50, 51:100)
a <- slow_sum(xs[[1]])
b <- slow_sum(xs[[2]])
y <- a + b
y
```

Think carefully which of the `<-` assignment operators you want to
parallelize. We don't want to over do it!

<details>
<summary>Solution</summary>
```{r}
library(future)
plan(multisession, workers = 4)

xs <- list(1:50, 51:100)
a %<-% slow_sum(xs[[1]])
b %<-% slow_sum(xs[[2]])
y <- a + b
y
```
</details>


### Parallel versions of purrr::map()

At the end of Lab 1, we learned how write our own parallel version of
`lapply()` using `future()` and `value()`.  We started by using for
loop to create the futures (= the parallel tasks), but then we noticed
that we could create them using `lapply()` instead.

```{r}
parallel_lapply <- function(X, FUN) {
  fs <- lapply(X, function(x) {
    future(FUN(x))
  })
  value(fs)
}
```

Here `value(fs)` will internally call `lapply(fs, value)`. For the
sake of what follows, let us explicity use that form;

```{r}
parallel_lapply <- function(X, FUN) {
  fs <- lapply(X, function(x) {
    future(FUN(x))
  })
  lapply(fs, value)
}
```

We can the use this to apply a function to each of the elements of a
list in parallel, e.g.

```{r}
library(future)
plan(multisession, workers = 4)

xs <- list(1:25, 26:50, 51:75, 76:100)
ys <- parallel_lapply(xs, slow_sum)
ys <- unlist(ys)
y <- sum(ys)
y
```


**Task `{r} task()`:**

Write a `parallel_map()` function that emulates what the `map()`
function of the **purrr** package does, while at the same tme running
in parallel using futures. I recommend that you modify the existing
`parallel_lapply()`. Verify that it works with:

```{r}
#| eval: false
library(future)
plan(multisession, workers = 4)

xs <- list(1:25, 26:50, 51:75, 76:100)
ys <- parallel_map(xs, slow_sum)
ys <- unlist(ys)
y <- sum(ys)
y
```


<details>
<summary>Solution</summary>
```{r}
library(purrr)

parallel_map <- function(X, FUN) {
  fs <- map(X, function(x) {
    future(FUN(x))
  })
  map(fs, value)
}
```
</details>

```{r, echo=FALSE}
xs <- list(1:25, 26:50, 51:75, 76:100)
ys <- parallel_map(xs, slow_sum)
ys <- unlist(ys)
y <- sum(ys)
stopifnot(y == 5050)
```


**Task `{r} task()`:**

Just like `lapply()` and `map()` return list, `parallel_lapply()` and
`parallel_map()` return lists. But, as in our example, it's common
that one wants the _atomic vector_ version of it, which is why we do:

```{r}
ys <- unlist(ys)
ys
```

Having to call this each time is tedious and adds friction and noise
to our code.  When not parallelizing, we can use **purrr**'s
`map_dbl()` to achieve the same in a one go;

```{r}
library(purrr)
xs <- list(1:25, 26:50, 51:75, 76:100)
ys <- map_dbl(xs, slow_sum)
y <- sum(ys)
y
```

Write your own `parallel_map_dbl()` that achieves the same, but via
futures, so that you can run:

```{r}
#| eval: false
library(purrr)
xs <- list(1:25, 26:50, 51:75, 76:100)
ys <- parallel_map_dbl(xs, slow_sum)
y <- sum(ys)
y
```

_Hint: Don't use `unlist()` - instead make use of `map_dbl()`. But
think carefully where in your function you want to use `map_dbl()`._

<details>
<summary>Solution</summary>
```{r}
library(purrr)

parallel_map_dbl <- function(X, FUN) {
  fs <- map(X, function(x) {
    future(FUN(x))
  })
  map_dbl(fs, value)
}
```
</details>


By now, you probably have one `map()` and one `map_dbl()` inside your
function. It is helpful to point out that it is the `map_dbl()` one
that makes `parallel_map_dbl()` emulate what `purrr::map_dbl()` does.
The other `map()` is just used to create our futures and put them in a
list.  We could equally well use `lapply()` for that. We could even
use a for loop as we used in Lab 1.  Because of this, all of the
following alternative solutions work equally well:


<details>
<summary>Solution 1</summary>
```{r}
parallel_map_dbl <- function(X, FUN) {
  fs <- purrr::map(X, function(x) {
    future(FUN(x))
  })
  purrr::map_dbl(fs, value)
}
```
</details>

<details>
<summary>Solution 2</summary>
```{r}
parallel_map_dbl <- function(X, FUN) {
  fs <- lapply(X, function(x) {
    future(FUN(x))
  })
  purrr::map_dbl(fs, value)
}
```
</details>

<details>
<summary>Solution 3</summary>
```{r}
parallel_map_dbl <- function(X, FUN) {
  fs <- list()
  for (ii in seq_along(X)) {
    x <- X[[ii]]
    fs[[ii]] <- future(FUN(x))
  }
  purrr::map_dbl(fs, value)
}
```
</details>


### Errors and parallel processing

The Futureverse has been designed such that your experience running
parallel code will be as close as possible to when you run regular,
sequential code. For example, if we call:

```{r, error = TRUE}
x <- "1.2"
y <- log(x)
```

we get an error.


**Task `{r} task()`:**

Try the same using the future assignment operator `%<-%`;

```{r, error = TRUE}
#| eval: false
y %<-% log(x)
y
```

_Do you get an error?_  Notice how similar it works to `<-`.


**Task `{r} task()`:**

Try the same, but now split up the `%<-%` into a `future()` and a
`value()` call. Start by calling:

```{r, error = TRUE}
#| eval: false
f <- future(log(x))
```

_Did you get an error or not? What could be the reason for that?_

<!-- We will not get an error until we collect the results, which only
happens when we try to get the value of `f`. -->

Next, ask for the value of the future;

```{r, error = TRUE}
#| eval: false
y <- value(f)
```

_What happens?_

<!-- Here we are requesting the value of `f`, which will trigger the
error to be signalled. -->


**Task `{r} task()`:**

Ask for the value one more time;

```{r, error = TRUE}
#| eval: false
y <- value(f)
```

_What happens now?_  What if you keep calling `value(f)` over and over?



**Task `{r} task()`:**

If we **purrr** as in:

```{r, error = TRUE}
library(purrr)

xs <- list(42, "1.2", 3.14)
y <- map_dbl(xs, log)
```

we get an error, because the second element of the `xs` list holds a
string instead of a numeric value.  That is what the error message
tries to explain to us.

Let's try with our `parallel_map_dbl()` function from above.

```{r, error = TRUE}
#| eval: false
library(future)
plan(multisession, workers = 4)

xs <- list(42, "1.2", 3.14)
y <- parallel_map_dbl(xs, log)
```

_Does it behave as you expected? Do you notice anything different? If
so, let's talk about it._



::: {.callout-note}

At first, it might appear obvious that we should get an error in these
cases and that it will look the same as when running regular
sequential code. But rest assured, Futureverse is the only parallel
framework that behave this way. If you use one of the traditional
frameworks you will get a different type of error, or not an error at
all. This is the case for `parLapply()` and `mclapply()` of
**parallel** as well as for `foreach()` and `%dopar%` of **foreach**.

:::


**Task `{r} task()`:**

Next, try the same but with `mclapply()` of the **parallel**
package;

```{r, echo = FALSE}
suppressWarnings(rm(list = c("xs", "ys")))
```

```{r, error = TRUE}
#| eval: false
library(parallel)

xs <- list("1.2", 42)
ys <- mclapply(xs, log)
print(ys)
```

_What happened - did you get an error? With the behavior you observed,
would you be able figure out what is wrong?  Also, what is the risk
with the current behavior?_



**Task `{r} task()`:**

Next, try the same but with `parLapply()` of the **parallel** package;

```{r, echo = FALSE}
suppressWarnings(rm(list = c("xs", "ys")))
```

```{r, error = TRUE}
#| eval: false
library(parallel)
workers <- makeCluster(4)

xs <- list("1.2", 42)
ys <- parLapply(xs, log, cl = workers)
print(ys)

stopCluster(workers)
```

_What happened - did you get an error? With the behavior you
observed, would you be able figure out what is wrong?_



### Warnings and parallel processing

Just like errors, warnings are signalled as-is when parallelizing via
futures.

**Task `{r} task()`:**

```{r}
#| eval: false
library(future)
plan(multisession, workers = 4)

xs <- list(42, -1.2, 3.14)
y <- parallel_map_dbl(xs, log)
y
```

_Did you get a warning?_


**Task `{r} task()`:**

Try the same with `mclapply()`;

```{r}
#| eval: false
library(parallel)
xs <- list(42, -1.2, 3.14)
y <- mclapply(xs, log)
y
```

_Did you get a warning?_


Then, try with `parLapply()`;

```{r}
#| eval: false
library(parallel)
workers <- makeCluster(4)
xs <- list(42, -1.2, 3.14)
y <- parLapply(xs, log, cl = workers)
y
stopCluster(workers)
```

_Did you get a warning?_



[Futureverse]: https://www.futureverse.org/
[future]: https://future.futureverse.org/
